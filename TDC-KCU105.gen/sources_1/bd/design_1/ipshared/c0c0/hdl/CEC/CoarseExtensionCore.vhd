-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
--                                                                                                                     --
--  __/\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_____/\\\\\\\\\\\__/\\\\\\\\\\\\\\\__/\\\_____________          --
--   _\///////\\\/////__\/\\\///////////__\/\\\////////\\\__\/////\\\///__\/\\\///////////__\/\\\_____________         --
--    _______\/\\\_______\/\\\_____________\/\\\______\//\\\_____\/\\\_____\/\\\_____________\/\\\_____________        --
--     _______\/\\\_______\/\\\\\\\\\\\_____\/\\\_______\/\\\_____\/\\\_____\/\\\\\\\\\\\_____\/\\\_____________       --
--      _______\/\\\_______\/\\\///////______\/\\\_______\/\\\_____\/\\\_____\/\\\///////______\/\\\_____________      --
--       _______\/\\\_______\/\\\_____________\/\\\_______\/\\\_____\/\\\_____\/\\\_____________\/\\\_____________     --
--        _______\/\\\_______\/\\\_____________\/\\\_______/\\\______\/\\\_____\/\\\_____________\/\\\_____________	   --
--         _______\/\\\_______\/\\\\\\\\\\\\\\\_\/\\\\\\\\\\\\/____/\\\\\\\\\\\_\/\\\\\\\\\\\\\\\_\/\\\\\\\\\\\\\\\_   --
--          _______\///________\///////////////__\////////////_____\///////////__\///////////////__\///////////////__  --
--                                                                                                                     --
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------


--------------------------BRIEF MODULE DESCRIPTION -----------------------------
--! \file
--! \brief Append a CoarseCount value to the input data (subint) if it is valid, then by means of the synchronizer it changes the clock domain, and and it manages the overflow internally.
--------------------------------------------------------------------------------


----------------------------- LIBRARY DECLARATION ------------------------------

------------ IEEE LIBRARY -----------
--! Standard IEEE library
library IEEE;
	--! Standard Logic Vector library
	use IEEE.STD_LOGIC_1164.all;
	--! Numeric library
	use IEEE.NUMERIC_STD.ALL;
--	--! Math operation over real number (not for implementation)
--	--use IEEE.MATH_REAL.all;
------------------------------------

-- ------------ STD LIBRARY -----------
-- --! Standard
-- library STD;
-- 	--! Textual Input/Output (only in simulation)
-- 	use STD.textio.all;
-- ------------------------------------


-- ---------- XILINX LIBRARY ----------
-- --! Xilinx Unisim library
-- library UNISIM;
-- 	--! Xilinx Unisim VComponent library
-- 	use UNISIM.VComponents.all;
--
-- --! \brief Xilinx Parametric Macro library
-- --! \details To be correctly used in Vivado write auto_detect_xpm into tcl console.
-- library xpm;
-- 	--! Xilinx Parametric Macro VComponent library
-- 	use xpm.vcomponents.all;
-- ------------------------------------


------------ LOCAL LIBRARY ---------
--! Internal Library
library work;
	--! CoarseExtensionCore Local Package
	use work.LocalPackage_CEC.all;
	--! TreeComparator Local Package
	use work.LocalPackage_TC.all;
------------------------------------

--------------------------------------------------------------------------------


-----------------------------ENTITY DESCRIPTION --------------------------------
--! \brief The output of this module contains *uncalib_tvalid*, that goes high if an overflow is detected (by means of the *TreeComparator*), and *uncalib_tdata* that is composed by
--! the FID part (with dimension *BIT_FID*) + coarse part (with dimension *BIT_COARSE*) + fine part (with dimension *BIT_UNCALIBRATED*). In input we have the subinterpolated data (*subint_tdata*) with dimension of *BIT_SUB_INT*, and the valid (*subint_tvalid*)
--! coming from the decoder. Moreover we have in input the *CoarseCounter_CTD*, that is used in case of *CEC_VS_CTD_COUNTER = "CTD"*. This module is also where the change of clock domain takes place, by means of the *FIFO_Synchronizer*, and where we count how many times the CoarseCounter overflows.
--------------------------------------------------------------------------------

entity CoarseExtensionCore is
	generic (

		----------------  Coarse Counter --------------
		CEC_VS_CTD_COUNTER	:	STRING						:= "CEC";			--! If *CEC* we choose the coarse counter generated by the internal CoarseExtensionCore, if *CTD* we choose the coarse counter caming from the external CoarseTreeDistributor

		CEC_COARSE_CNT_INIT	:	NATURAL						:= 0;				--! Initialization Value of the Internal Coarse Counter in CoarseExtensionCore
		BIT_COARSE			:	POSITIVE	RANGE 1 TO 32	:= 8;				--! Bit Dimension of the Coarse part of the Timestamp

		INTERNAL_OVERFLOW_CNT	:	BOOLEAN		:=	FALSE;						--! Generic used for deciding whether to count the overflows in the CEC (if *INTERNAL_OVERFLOW_CNT* is TRUE) or leave the Overfow Counter the task of counting (if *INTERNAL_OVERFLOW_CNT* is FALSE)
		----------------------------------------------

		------------- Uncalibrated Dimension --------
		----- Uncalibrated -----
		BIT_SUB_INT			:	POSITIVE	RANGE	2	TO	16	:=	10;			--! Number of Bit of SubInterpolated TDL
		BIT_UNCALIBRATED	:	POSITIVE	RANGE	2	TO	16	:=	10;			--! Number of Bit of Uncalibrated_TDL (Default, Equal to BIT_SUB_INT)
		------------------------

		-------- BeltBus -------
		BIT_FID				:	POSITIVE 	:=	1;								--! Function ID of the Belt Bus, if bit0 of *FID* =0 we have an OVERFLOW , if = 1 we MEASURE. If BIT_FID = 1 the belt bus is removed and it is a standard AXI4 stream, the MSBs of BIT_FID are used for aditional (e.g. polarity)
		------------------------
		----------------------------------------------

		--------------- xpm_fifo_async ---------------
		FIFO_MEMORY_TYPE	:	STRING							:=	"distributed";      		--! Type of FIFO; "auto", "block", or "distributed";
		RELATED_CLOCKS		:	INTEGER	RANGE	0	TO	1		:=	0;							--! Specifies if the wr_clk (s00_uncalibTDC_aclk) and rd_clk (m00_uncalibSYS_aclk) are related, if 1 clk_TDC and clk_SYS are locked
		FIFO_WRITE_DEPTH	:	INTEGER	RANGE	16	TO	4194304	:=	16;           				--! FIFO Depth, Power of 2
		CDC_SYNC_STAGES		:	INTEGER	RANGE	2	TO	8		:=	4;							--! Cross Domain Clock Synch Stages: specifies the number of synchronization stages on the CDC path. It must be < 5 if *FIFO_WRITE_DEPTH = 16*
		----------------------------------------------


		--------------  Tree Comparator --------------
		------ Stage 0 -----
		MAX_NUM_BIT_EQ_PIPELINE_STAGE0		: 	POSITIVE 	RANGE 1 TO 32   := 3;				--! Blocks of bits of the inputs that we want to compare in the first stage (Equality comparison)
		--------------------

		-- Others Stages ---
		MAX_INPUT_ENGINE_PIPELINE	:	TC_POSITIVE_ARRAY_TYPE := (2, 2)		--! Select the max number of input per stage, the EQ stage must have 2 inputs
		--------------------
		----------------------------------------------




	);
	port(
		------------------ Reset/Clock ---------------
		--------- Reset --------
		reset_SYS   :	IN    STD_LOGIC;																		--! Asynchronous system reset active high
		reset_TDC	:	IN    STD_LOGIC;																		--! Asynchronous TDC reset active high
		------------------------

		--------- Clocks -------
		clk_TDC     :	IN    STD_LOGIC;		 																--! Sampling clock at clk_TDC. It is the TDC clock before the synchronizer
		clk_SYS     :	IN    STD_LOGIC;		 																--! Sampling clock at clk_SYS. It is the system clock after the synchronizer
		------------------------
		----------------------------------------------

		--- CTD External Coarse Count (CNT) Value ----
		CoarseCounter_CTD	:	IN	STD_LOGIC_VECTOR(BIT_COARSE-1 downto 0);									--! Value of the External Coarse Counter come from CTD
		---------------------------------------------

		-------------------- Data ------------------
		-----  Decoded TDL ----
		subint_tvalid	: IN	STD_LOGIC;																	--! Valid of the SubInterpolated TDL
		subint_tdata	: IN	STD_LOGIC_VECTOR(1 + BIT_SUB_INT-1 downto 0);								--! Polarity + Decoded Subinterpolated TDL (Default, Equal to BIT_UNCALIBRATED)
		------------------------

		---  Uncalibrated TDL --
		uncalib_tvalid	: OUT	STD_LOGIC;																	--! Valid of Decoded of TDL with pipeline of Coarse Counter
		uncalib_tdata	: OUT	STD_LOGIC_VECTOR(BIT_FID + BIT_COARSE + BIT_UNCALIBRATED-1 downto 0)		--! Data from Coarse Counter pipelined | Decoded of TDLs sub-interpolated => |COARSE|SUB_INT|
		------------------------
		-------------------------------------------




	);
end CoarseExtensionCore;

------------------------ ARCHITECTURE DESCRIPTION ------------------------------
--! \brief The aims of the module is basically one: it has to append the CoarseCounter and the FID to the fine part of the measurement. To do that, the module exploits other 2 modules: the *FIFO_Synchronizer* and the *TreeComparator*.
--! The *FIFO_Synchronizer* is used to change the clock domain from *clk_TDC* to *clk_SYS*, and it is useful not to loose 2 following measurements, that was the defect of the previous version. According to the cases that will be explained later, the *FIFO_Synchronizer*
--! will compose the output *uncalib_tdata*: in the case of overflow, it is composed by a FID part and a part that contains the value of the *CoarseOverflow_cnt*. Instead in case of measure only, we have the classical FID + COARSE + FINE part. So in other words in output of the module we will have
--! the *CoarseOverflow_cnt* in case of overflow, or the measurement in case of no overflow. The overflow of the *CoarseCounter* is detected by the *TreeComparator*.
--! \image html Output_bits.svg [Bit structure of the output]
--! \details Then we can see an example of the output of the module, in case of no overflow:
--! \image html Output.svg [Output Image]
--! \details If *BIT_FID = 1* the Belt Bus is removed and the output is a standard AXI4 Stream. The LSB of the FID field is used to manage the overflow, the others BIT_FID-1 came from previus modeule (e.g. polarity for ToT).
--! In this case the module if *subint_tvalid = '1'* pads the *subint_tdata* with a Coarse Counter part coming from CoarseCounter_CTD,
--! if *CEC_VS_CTD_COUNTER = "CTD"* or generated internally, if *CEC_VS_CTD_COUNTER = "CEC"*.
--! The module then instantiates the *FIFO_Synchronizer* and the *TreeComparator*. The *TreeComparator* is used to understand if the *CoarseCounter* reaches the overflow. In order to do that, first the module exploits the function *Compute_TC_PipelineStage* to compute how many stages
--! are present in the *TreeComparator*. Then the module sets the constant *OVERFLOW_REF* used as a reference for the *TreeComparator* for understanding if the counter overflows. The *CoarseCounter*
--! reaches the overflow when it is equal to *OVERFLOW_REF*, and *OVERFLOW_REF* is equal to 2^BIT_COARSE - 1 - NUM_STAGE. (We have to subtract also NUM_STAGE because we have to take the delay of the pipeline into account)
--! When the output of the *TreeComparator* (*Equality_check*) is '1', it means that the *CoarseCounter* has reached the overflow (*CoarseCounter = 2^BIT_COARSE -1*), and so we can update the counter of the overflow *CoarseOverflow_cnt*.
--! Then since the *FIFO_Synchronizer* works with 2 different clocks, one for writing (*clk_TDC*) and one for reading (*clk_SYS*) we have 2 processes.
--! The first process *TDC_process* works at *clk_TDC* and it is the responsible of writing the *FIFO_Synchronizer*. First of all in the process at each rising edge, we set to '0' the *wr_en*, the MSB of the input signal to be stored of the FIFO *din(BIT_COARSE + 1 + BIT_SUB_INT)*, and the bit that contains the valid of the input data of the FIFO *din(BIT_SUB_INT)*.
--! This means that initially we are not able to write in the FIFO, there is no overflow and the data is not valid. Then if *subint_tvalid = 1* it means that the input data is valid, and so we can write it in the FIFO. The stored data in this case has the MSB that is '0', which means no overflow, then the following *BIT_COARSE* contains the *CoarseCounter*, and *din(BIT_SUB_INT)*
--! is set to '1', so the din is valid, and the LSBs contains the fine part of the time stamp that is *subint_tdata*.
--! Then if *BIT_FID /= 0* and the value of the Coarse Counter is in overflow (*Equality_check = '1'* ) the *wr_en* is forced to '1'
--! and we set the MSB of din to '1', meaning that there is an overflow.
--! The *TDC_process* can be summarized by the following image:
--! \image html TDC_pr.svg [TDC process]
--! Then the second process *Sys_process* works at *clk_SYS* and it is responsible of reading the FIFO, and bringing in output the CEC content. First *uncalib_tvalid* is set to '0' and *rd_en* to '1'.
--! The reading phase happens in this way. If *rd_en = 1* we look at the read port of the FIFO (dout)  and we can have different cases depending on what has been stored previously in the *TDC_process*.
--! If we have dout(BIT_SUB_INT) = '1' and dout(BIT_COARSE + 1 + BIT_SUB_INT) = '0' it means that we have a valid data (subint_tdata*) and we have no coarse overflow respectively, so in output *uncalib_tdata* will contain a FID PART (MSB) equal to *FID_MEASURE_BIT0*, a coarse part equal to the CoarseCounter stored in the previous process, and the fine part equal to the measure *subint_tdata* stored in the
--! previous process. Then if dout(BIT_SUB_INT) = '0' and dout(BIT_COARSE + 1 + BIT_SUB_INT) = '1' it means that the data is not valid and there is coarse overflow, so in output *uncalib_tdata* will contain a FID PART (MSB) equal to *FID_OVERFLOW_BIT0*, and a part containing the updated value of *CoarseOverflow_cnt*, that counts how many times the *CoarseCounter* overflows.
--! Remember that the FID part is 0 during an overflow, 1 in a standard measure.
--! The last case is dout(BIT_SUB_INT) = '1' and dout(BIT_COARSE + 1 + BIT_SUB_INT) = '1' that means that we have both a valid data (subint_tdata*) and an overflow. So here we have a problem, that is deciding what to bring out, since in principle we have to bring out both the oveflow counter signal and the measure. What is done here is first to set to '0' the read enable (*rd_en*) signal of the FIFO, such that
--! if in the following clock cycle we don't read any new dout signal. Then the output *uncalib_tdata* is composed by the FID_OVERFLOW_BIT0 and the updated version of the *CoarseOverflow_cnt*. So first we bring to output the Overflow counter. In the meanwhile, we store temporarily the measure, and we set to '1' the signal 'queue', that is a kind of flag to say that we have a measure that is waiting. Then the next clock cycle, since *rd_en* is '0', we don't
--! read new data, but we read the measure that is waiting from the previous clock cycle. In this way we don't loose any measure.
--! The *Sys_process* can be summarized by the following image:
--! \image html Sys.svg [Sys process]
--! \details Since in the previous versions of the TDC there was also a module that was used to compute the number of overflows (*AXI4Stream_OverflowCounter*) of the CoarseCounter, but here is not exploited (we manage the overflow count internally), below there is the README of that module:
--! \htmlonly
--! <embed src="README_OC.pdf" width="100%" heigth="100%" href="SamplePDFFile.pdf"></embed>
--! \endhtmlonly
--! In the doc folder, there is the corresponding pdf file.
--------------------------------------------------------------------------------

architecture Behavioral of CoarseExtensionCore is

	------------------------- FUNCTIONS DECLARATION ----------------------------

	--------- Num stage computation ---------
	--! This function is used to compute how many stages are present in the *TreeComparator* in order to find the reference signal (*OVERFLOW_REF*) with which the *TreeComparator* will make the comparison. Basically to do that
	--! it exploits the functions *step_TC_pipeline_init* and *step_TC_max_input_engine_init* that have already been described in the *LocalPackage_TC*.

	function Compute_TC_PipelineStage(

		max_num_bit_eq_pipeline_stage0			:	POSITIVE;

		max_input_engine_pipeline	:	TC_POSITIVE_ARRAY_TYPE;

		bit_data			:	POSITIVE

	) return integer is

		variable max_input_engine_and_pipeline_stage1 : positive	:= max_input_engine_pipeline(1);
		variable max_input_engine_and_pipeline_stage2 : positive	:= max_input_engine_pipeline(2);
		variable max_input_engine_and_pipeline_stage3 : positive	:= max_input_engine_pipeline(3);

	begin



		-- Pipeline TC Stage-by-Stage Settings Array
		return
			step_TC_pipeline_init(

				-- MAX_INPUT_PER_ENGINE_ARRAY
				step_TC_max_input_engine_init(
					2,																		-- The first stage has 2 inputs
					max_input_engine_and_pipeline_stage1,
					max_input_engine_and_pipeline_stage2,
					max_input_engine_and_pipeline_stage3,
					max_input_engine_and_pipeline_stage3,
					max_input_engine_and_pipeline_stage3,
					max_input_engine_and_pipeline_stage3,
					max_input_engine_and_pipeline_stage3
				),

				-- Bit Data
				bit_data,

				-- MAX_NUM_BIT_EQ_PIPELINE_STAGE0
				max_num_bit_eq_pipeline_stage0
			)'LENGTH;

	end function;
	----------------------------------------------------------------------------

	------------------------- CONSTANTS DECLARATION ----------------------------
	constant	BIT_OVERFLOW_CNT	:	NATURAL		:=	BIT_COARSE + BIT_UNCALIBRATED;		--! Maximum bit dimension of the counter of the OVERFLOW of the Coarse

	constant	FID_OVERFLOW		:	STD_LOGIC_VECTOR(BIT_FID-1 downto 0)	:=			--! FID = 0 means overflow
		std_logic_vector(
			to_unsigned(
				0,
				BIT_FID
			)
		);

	constant	FID_MEAS_RISE		:	STD_LOGIC_VECTOR	:=								--! FID = 11 means measure (bit0=1) on the rising edge (bit1=1)
		std_logic_vector(
			to_unsigned(
				3,
				BIT_FID
			)
		);

	constant	FID_MEAS_FALL		:	STD_LOGIC_VECTOR	:=								--! FID = 11 means measure (bit0=1) on the falling edge (bit1=0)
		std_logic_vector(
			to_unsigned(
				1,
				BIT_FID
			)
		);


	--constant	BIT_COARSE_EVEN		:	NATURAL	:=	BIT_COARSE;					--	TODO Generale
	--constant	STEP_OVERFLOW		:	NATURAL	:=	BIT_COARSE_EVEN/2 +1;

	--constant	OVERLOW_REF_SLV		:	STD_LOGIC_VECTOR(BIT_COARSE_EVEN-1 downto 0)	:=   								-- 1
	--	std_logic_vector(
		--	to_unsigned(
		--		OVERLOW_REF,
			--	BIT_COARSE_EVEN
			--)
		--);


	------------- FIFO_Synchronizer --------------
	--! \brief The *DATA_WIDTH* is composed by:
	--! - the MSB is the bit that indicates if the *CoarseCounter* overflows ('1') or not ('0').
	--! - Then we have *BIT_COARSE* bits that contains the *CoarseCounter*.
	--! - Then we have a bit that contains the valid (*subint_tvalid*)
	--! - The last LSBs are the fine part of the timestamp (*subint_tdata*)
	--! \details It is also the Fifo dimension

	constant	DATA_WIDTH			:	POSITIVE	:=	BIT_FID + BIT_COARSE + 1 + BIT_UNCALIBRATED;		--! All BIT_FID - bit0 that is the overflow, 1 used to advice the voerflow, BIT_COARSE, 1 used to advie the valid of TDC, BIT_UNCALIBRATED
	----------------------------------------------

	--------------  Tree Comparator -------------
	constant	OVERFLOW_REF	:	POSITIVE	:= 			--! The reference value that is used by the *TreeComparator* for making the comparison with the *CoarseCounter is equal to 2^BIT_COARSE -NUM_STAGE -1. The subtraction of the NUM_STAGE is needed because we have to take into account the delay created by the pipeline of the *TreeComparator*.
	(2**BIT_COARSE) -
	Compute_TC_PipelineStage(

		MAX_NUM_BIT_EQ_PIPELINE_STAGE0,

		MAX_INPUT_ENGINE_PIPELINE,

		BIT_COARSE

	);
	---------------------------------------------
	----------------------------------------------------------------------------

	--type OVERFLOW_ARRAY_TYPE	is array(0 to STEP_OVERSTEP_OVERFLOWFLOW-1) of STD_LOGIC_VECTOR(BIT_COARSE_EVEN-1 downto 0);



	------------------------ COMPONENTS DECLARATION ----------------------------

	---- Internal Coarse Counter Generation ------
	--! \brief Counter used to give the coarse part of the timestamp.

	COMPONENT CoarseCounter_CEC
		generic(
			------------- Inizializzation -----------
			COARSE_CNT_INIT	:	NATURAL	:=	0;									-- Initialization Value
			-----------------------------------------

			---------------- Dimension ---------------
			BIT_COARSE		:	POSITIVE	RANGE 1 TO 32	:= 8				-- Bit of Coarse Counter
			-----------------------------------------
		);
		port (

			---------------- Reset/Clock ------------
			--------- Reset --------
			reset   : IN    STD_LOGIC;
			------------------------

			--------- Clocks -------
			clk     : IN    STD_LOGIC;
			------------------------
			-----------------------------------------

			---- Coarse Count (CNT) Value Output ----
			CoarseCounter_CEC	:	OUT	STD_LOGIC_VECTOR(BIT_COARSE-1 downto 0) -- Counting at clk
			-----------------------------------------

		);
	END COMPONENT;
	-----------------------------------------------


	------------------------ FIFO Synchronizer  -------------------------
	--! \brief The FIFO_Synchronizer instantiates a Xilinx Asynchronous XPM FIFO
	COMPONENT FIFO_Synchronizer
		generic (

			--------------- xpm_fifo_async ---------------
			DATA_WIDTH			:	POSITIVE						:=	16;														-- Fifo Dimension

			FIFO_MEMORY_TYPE	:	STRING							:=	"distributed";							-- Type of FIFO; "auto", "block", or "distributed";
			RELATED_CLOCKS		:	INTEGER	RANGE	0	TO	1		:=	0;											-- If 1 clk_TDC and clk_SYS are locked
			FIFO_WRITE_DEPTH	:	INTEGER	RANGE	16	TO	4194304	:=	16;            		-- FIFO Depth, Power of 2
			CDC_SYNC_STAGES		:	INTEGER	RANGE	2	TO	8		:=	4												-- Cross Domain Clock Synch Stages
			----------------------------------------------

		);

		port(

			------------ Input port at  wr_clk ------------
			wr_clk	:	IN	STD_LOGIC;																						-- write clock
			wr_en	:	IN	STD_LOGIC;																							-- write enable
			din		:	IN	STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0); 								-- write port
			-----------------------------------------------

			--------- Uncalibrated Output @ clk_SYS ------
			rd_clk		:	IN	STD_LOGIC;																					-- read clock
			data_valid	:	OUT	STD_LOGIC;																				-- dout valid
			rd_en	:	IN	STD_LOGIC;
			dout		:	OUT	STD_LOGIC_VECTOR(DATA_WIDTH-1 DOWNTO 0) 							-- dout
			-----------------------------------------------

		);
	END COMPONENT;
	------------------------------------------------------------------




	---- TreeComparator ------
	--! \brief Comparator in pipeline used to detect the overflow of the *CoarseCounter*
	COMPONENT TreeComparator
		generic (

			---- Tuning mode ---
			TUNING_MODE		: 	BOOLEAN		:= FALSE;												-- Choice between port and generic: if 'TRUE' we choose the port *Ref*, if 'FALSE' we choose the generic *REF_INIT*
			--------------------

			--- Gest Pipeline ---
			FREE_RUNNING						:	BOOLEAN	:= FALSE;								-- Free running option
			---------------------

			------ Stage 0 -----
			MAX_NUM_BIT_EQ_PIPELINE_STAGE0		: 	POSITIVE 	RANGE 1 TO 32   := 3;				-- Blocks of bits of the inputs that we want to compare in the first stage (Equality comparison)
			--------------------

			-- Others Stages ---
			MAX_INPUT_ENGINE_PIPELINE	:	TC_POSITIVE_ARRAY_TYPE := (2, 2);		-- Select the max number of input per stage, the EQ stage must have 2 inputs
			--------------------

			------ Bit Dim ------
			BIT_DATA		: 	POSITIVE	RANGE 1 TO 32 := 12;									-- Number of bits of the input Data and of the reference signal
			--------------------

			-- Initialization Ref --
			REF_INIT		: 	INTEGER := (2**16 -1) -4														-- Reference signal in case of *TUNING_MODE = FALSE*
			------------------------


		);
		port(

			------ Reset ------
			Reset	: IN	STD_LOGIC;												-- Asynchronous reset active high
			-------------------

			------ Clocks ------
			Clk	: IN	STD_LOGIC;													-- Clock signal
			--------------------

			------- Enable ----------
			SoC		: IN STD_LOGIC;													-- Start of conversion: if FREE_RUNNING = FALSE, we sample the result only if SoC = '1'
			EoC		: OUT STD_LOGIC;												-- End of conversion. Basically it is our valid for the output. When it is '1', the output is 'valid'
			-------------------------

			------ In Pipeline ------
			Data	: IN	STD_LOGIC_VECTOR(BIT_DATA-1 downto 0);					-- Input data to be compared with the reference (*Ref* if TUNING_MODE = TRUE , *REF_INIT* if TUNING_MODE = FALSE)
			Ref		: IN	STD_LOGIC_VECTOR(BIT_DATA-1 downto 0);					-- Signal used as reference for the input data
			-------------------------

			-------------------------------------------
			------ Out Pipeline ------
			Equality_check	: OUT	STD_LOGIC										-- Output of the pipeline: '1' if Data and Ref are equal, '0' if they are different
			--------------------------
		);
	END COMPONENT;
	------------------------
	----------------------------------------------------------------------------






	-------------------------- SIGNALS DECLARATION -----------------------------

	----- Coarse CNT and SubInt TDL Input --------
	signal	CoarseCounter	:	STD_LOGIC_VECTOR(BIT_COARSE-1 downto 0);					                	--! Value of the Internal Coarse Counter
	--signal	overflow_array	:	OVERFLOW_ARRAY_TYPE	:=	(Others => (Others => '1'));
	----------------------------------------------

	------------- FIFO_Synchronizer --------------
	signal	wr_en	:	STD_LOGIC	:=	'0';												--! Write enable of the FIFO
	signal	din		:	STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);							--! Input signal of the FIFO. The bit structure of this signal is present in the description of the constant *DATA_WIDTH*

	signal	data_valid	:	STD_LOGIC;													--! The FIFO is not empty
	signal	rd_en		:	STD_LOGIC	:=	'0';										--! Read enable
	signal	dout		:	STD_LOGIC_VECTOR(DATA_WIDTH-1 downto 0);					--! Output signal of the FIFO. The bit structure of this signal is present in the description of the constant *DATA_WIDTH*
	----------------------------------------------

	------- Coarse Counter OverFlow Manage -------
	signal	queue				:	STD_LOGIC	:=	'0';														--! Signal used to understand if in output of the FIFO we have to send both an overflow data and a real data. This signal is basically a memo used to say that we have a data that is waiting to be sent
	signal	CoarseOverflow_cnt	:	UNSIGNED(BIT_OVERFLOW_CNT-1 downto 0);										--! Overflow Counter, that counts how many times the CoarseCounter overflows
	signal	uncalib_tdata_tmp	:	STD_LOGIC_VECTOR(BIT_FID + BIT_COARSE + BIT_UNCALIBRATED-1 downto 0);		--! Signal used to store temporarily the output data of the FIFO, since in the case we have to extract both the overflow counter and the data from the FIFO, first we send out the Overflow counter, and then the following clock cycle the data that is in queue.
	----------------------------------------------

	------- Coarse Counter OverFlow Manage -------
	signal Equality_check		:	STD_LOGIC	:= '0';								--! Output of the pipeline: '1' if Data and Ref are equal, '0' if they are different
	----------------------------------------------
	----------------------------------------------------------------------------


	--------------------------------- ALIASES ----------------------------------
	-- -------------------- Sub Int --------------------
	-- alias	subint	:	STD_LOGIC_VECTOR(BIT_SUB_INT -1 downto 0)							-- Portion of SubInt reserved to uncalibrated fine measurment
	-- is		subint_tdata(BIT_SUB_INT-1 downto 0);
	--
	-- alias	polarity	:	STD_LOGIC														-- Portion of SubInt reserved to polarity
	-- is		subint_tdata(BIT_SUB_INT downto BIT_SUB_INT);
	-- ----------------------------------------------

	---------------------- Din ----------------------
	alias	din_uncalibrated	:	STD_LOGIC_VECTOR(BIT_UNCALIBRATED-1 downto 0)			-- Portion of Din reserved to uncalibrated fine measurment
	is		din(BIT_UNCALIBRATED-1 downto 0);

	alias	din_measurement		:	STD_LOGIC_VECTOR(0 downto 0)							-- Portion of Din reserved to advice if a measure is injected (if '1')
	is		din(BIT_UNCALIBRATED downto BIT_UNCALIBRATED);

	alias	din_coarse			:	STD_LOGIC_VECTOR(BIT_COARSE-1 downto 0)					-- Portion of Din reserved to Coarse Counter
	is		din(BIT_COARSE + 1 + BIT_UNCALIBRATED -1 downto 1 + BIT_UNCALIBRATED);

	alias	din_overflow		:	STD_LOGIC_VECTOR(0 downto 0)							-- Portion of Din reserved to advice if an overflow is asserted (if '1')
	is		din(1 + BIT_COARSE + 1 + BIT_UNCALIBRATED -1 downto BIT_COARSE + 1 + BIT_UNCALIBRATED);

	alias	din_polarity		:	STD_LOGIC_VECTOR(0 downto 0)							-- Portion of Din reserved to advice if an overflow is asserted (if '1')
	is		din(1 + 1 + BIT_COARSE + 1 + BIT_UNCALIBRATED -1 downto 1 + BIT_COARSE + 1 + BIT_UNCALIBRATED);
	----------------------------------------------

	-------------------- Dout --------------------
	alias	dout_uncalibrated	:	STD_LOGIC_VECTOR(BIT_UNCALIBRATED-1 downto 0)			-- Portion of Dout reserved to uncalibrated fine measurment
	is		dout(BIT_UNCALIBRATED-1 downto 0);

	alias	dout_measurement	:	STD_LOGIC_VECTOR(0 downto 0)							-- Portion of Dout reserved to advice if a measure is injected (if '1')
	is		dout(BIT_UNCALIBRATED downto BIT_UNCALIBRATED);

	alias	dout_coarse			:	STD_LOGIC_VECTOR(BIT_COARSE-1 downto 0)					-- Portion of Dout reserved to Coarse Counter
	is		dout(BIT_COARSE + 1 + BIT_UNCALIBRATED -1 downto 1 + BIT_UNCALIBRATED);

	alias	dout_overflow		:	STD_LOGIC_VECTOR(0 downto 0)							-- Portion of Dout reserved to advice if an overflow is asserted (if '1')
	is		dout(1 + BIT_COARSE + 1 + BIT_UNCALIBRATED -1 downto BIT_COARSE + 1 + BIT_UNCALIBRATED);

	alias	dout_polarity		:	STD_LOGIC_VECTOR(0 downto 0)							-- Portion of Dout reserved to advice if an overflow is asserted (if '1')
	is		dout(1 + 1 + BIT_COARSE + 1 + BIT_UNCALIBRATED -1 downto 1 + BIT_COARSE + 1 + BIT_UNCALIBRATED);
	----------------------------------------------

	----------------------------------------------------------------------------


begin



	----------------------- COMPONENTS INSTANTIATION ---------------------------

	----- Internal Coarse Counter Generation ------
	--! \brief The instantiation is done in a different way depending on the value of CEC_VS_CTD_COUNTER:
	--! If it is set to "CEC", the CoarseCounter_CEC is instantiated, otherwise, CoarseCounter is put equal to
	--! CoarseCounter_CTD, that is the counter coming from the CTD.
	--! If *CoarseCounter_CEC* is instantiated, it has the same *COARSE_CNT_INIT*, *BIT_COARSE*, *clk* and *reset* of the *CoarseExtensionCore*, and the *CourseCounter_CEC*
	--! is associated to the signal CoarseCounter of the *CoarseExtensionCore*.

	IntCnt : if CEC_VS_CTD_COUNTER = "CEC" generate
		Inst_CoarseCounter_CEC	:	CoarseCounter_CEC
			generic map(
				------------- Initialization ------------
				COARSE_CNT_INIT	=>	CEC_COARSE_CNT_INIT,
				-----------------------------------------

				-------------- Dimension -----------------
				BIT_COARSE		=>	BIT_COARSE
				-----------------------------------------
			)
			port map (

				---------------- Reset/Clock ------------
				--------- Reset --------
				reset   =>	reset_TDC,
				------------------------

				--------- Clocks -------
				clk     =>	clk_TDC,
				------------------------
				-----------------------------------------

				---- Coarse Count (CNT) Value Output ----
				CoarseCounter_CEC	=>	CoarseCounter
				-----------------------------------------

			);
	end generate;
	-----------------------------------------------

	----- External Coarse Counter Acquisition -----
	ExtCnt : if CEC_VS_CTD_COUNTER = "CTD" generate
		CoarseCounter	<= CoarseCounter_CTD;
	end generate;
	-----------------------------------------------



	----------------------- FIFO Synchronizer  -----------------------
	--! \brief Each generic/port of the FIFO are associated in a proper way to the generic/port/constant
	--! of the *CoarseExtensionCore*

	Inst_FIFO_Synchronizer	:	FIFO_Synchronizer

		generic map(

			--------------- xpm_fifo_async ---------------
			DATA_WIDTH			=>	DATA_WIDTH,

			FIFO_MEMORY_TYPE	=>	FIFO_MEMORY_TYPE,
			RELATED_CLOCKS		=>	RELATED_CLOCKS,
			FIFO_WRITE_DEPTH	=>	FIFO_WRITE_DEPTH,
			CDC_SYNC_STAGES		=>	CDC_SYNC_STAGES
			----------------------------------------------

		)

		port map(

			------------ Input port at  wr_clk ------------
			wr_clk           => clk_TDC,
			wr_en            => wr_en,
			din              => din,
			-----------------------------------------------

			--------- Uncalibrated Output @ clk_SYS ------
			rd_clk           => clk_SYS,
			rd_en		 	 =>	rd_en,
			data_valid       => data_valid,								-- is not empty
			dout             => dout
			-----------------------------------------------

		);
	----------------------------------------------------------------

	--------------- TreeComparator ----------------
	--! \brief We set always *TUNING_MODE = FALSE* and *FREE_RUNNING = TRUE*, in this way the comparison is done with the contant *OVERFLOW_REF* and we continuously look at the output *Equality_check*.
	--! *BIT_DATA* is the same of  *BIT_COARSE* and *REF_INIT* is associated to *OVERFLOW_REF*. The *SoC* port is always set to '1', and this is the same of having *FREE_RUNNING = TRUE*. Then
	--! the port *EoC* is left open, we are not interested in it, and for the same reason also the port *Ref* is set to all zeros. Indeed if *TUNING_MODE = FALSE* the port *Ref* is not considered.
	Inst_TreeComparator: TreeComparator
		generic map (

			-------------  Tree Comparator --------------
			---- Tuning mode ---
			TUNING_MODE		=>	FALSE,
			--------------------

			---- Gest Pipeline ---
			FREE_RUNNING	=>	TRUE,
			--------------------

			------ Stage 0 -----
			MAX_NUM_BIT_EQ_PIPELINE_STAGE0 			=> MAX_NUM_BIT_EQ_PIPELINE_STAGE0,
			--------------------
			-- Others Stages ---
			MAX_INPUT_ENGINE_PIPELINE			=>	MAX_INPUT_ENGINE_PIPELINE,
			--------------------

			----------------------------------------------

			------ Bit Dim ------
			BIT_DATA	=>	BIT_COARSE,
			--------------------

			-- Initialization Ref --
			REF_INIT	=> OVERFLOW_REF
			------------------------

		)
		port map(

			------ Reset ------
			Reset	=> reset_TDC,
			-------------------

			------ Clocks ------
			Clk	=> clk_TDC,
			--------------------

			----- Enable ------
			SoC	=> '1',
			EoC	=> open,
			--------------------
			------ In Pipeline ------
			Data	=>	CoarseCounter,
			Ref		=>	(Others => '0'),		-- Not Used
			-------------------------

			------ Out Pipeline ------
			Equality_check	=> Equality_check
			--------------------------
		);
	-----------------------------------------------

	----------------------------------------------------------------------------





	------------------------- SYNCHRONOUS PROCESS --------------------------------


	------------- Writing the FIFO ----------
	--! \brief This is the process used to write the FIFO. How it works is descibed in the Architecture descritption section.
	TDC_process : process (clk_TDC, reset_TDC)


	begin

		if (reset_TDC = '1') then
			wr_en		<=	'0';

		elsif rising_edge (clk_TDC) then

			---------- Reset ----------
			wr_en				<=	'0';
			din_overflow		<=	"0";
			din_measurement		<=	"0";
			-----------------------------


			------- Fine Part ---------
			if subint_tvalid = '1' then

				wr_en	<= '1';

				-- bit1 FID (Polarity) only if is consider in the FID
				if BIT_FID > 1 then
					din_polarity	<= subint_tdata(BIT_SUB_INT downto BIT_SUB_INT);
				end if;

				-- bit0 FID (Overflow)
				din_overflow	<=	"0";

				-- BIT COARSE
				din_coarse	<=	CoarseCounter;

				-- valid TDC
				din_measurement	<=	"1";

				-- BIT_SUB_INT in BIT_UNCALIBRATED
				InputFIFOMaker(
					subint_tdata(BIT_SUB_INT-1 downto 0),
					din(BIT_UNCALIBRATED -1 downto 0)
					);


			end if;
			-----------------------------

			------- Coarse Part ----------
			-- if BIT_FID /= 0 and CoarseCounter = (CoarseCounter'RANGE => '0') then
			if BIT_FID > 0 and Equality_check = '1' then
					wr_en			<=	'1';
					din_overflow	<=	"1";

			end if;
			-----------------------------


		end if;

	end process;
	-----------------------------------------

	------------ Reading the FIFO ----------
	--! \brief This is the process used to read the FIFO. How it works is descibed in the Architecture descritption section.
	SYS_process : process(clk_SYS, reset_SYS)
	begin

		if (reset_SYS = '1') then
			uncalib_tvalid		<=	'0';
			CoarseOverflow_cnt	<=	to_unsigned(1,BIT_OVERFLOW_CNT);

			rd_en	<=	'0';
			queue		<=	'0';

		elsif rising_edge (clk_SYS) then

			uncalib_tvalid	<=	'0';
			rd_en	<=	'1';


			if data_valid = '1' then

				-- the data is valid and there is no coarse overflow  --> the FIFO sends in output the measure
				if dout_measurement = "1" and dout_overflow = "0" then
					uncalib_tvalid	<=	'1';
					if dout_polarity = "1" then
						uncalib_tdata	<= FID_MEAS_RISE&dout_coarse&dout_uncalibrated;
					elsif dout_polarity = "0" then
						uncalib_tdata	<= FID_MEAS_FALL&dout_coarse&dout_uncalibrated;
					end if;


				--the data is not valid and there is no coarse overflow --> we send in output the value of the overflow counter
				elsif dout_measurement = "0" and dout_overflow = "1" then
					uncalib_tvalid																					<=	'1';
					uncalib_tdata(BIT_FID + BIT_COARSE + BIT_UNCALIBRATED -1 downto BIT_COARSE + BIT_UNCALIBRATED)	<=	FID_OVERFLOW;
					if 	INTERNAL_OVERFLOW_CNT = TRUE then
						uncalib_tdata(BIT_COARSE + BIT_UNCALIBRATED -1 downto 0)									<=	std_logic_vector(CoarseOverflow_cnt);
						CoarseOverflow_cnt	<=	CoarseOverflow_cnt + 1;

					end if;

				--the data is valid and there is no coarse overflow --> we send in output the value of the overflow counter and the data
				elsif dout_measurement = "1" and dout_overflow = "1" then
					rd_en	<=	'0';

					-- Send as First the Overflow
					uncalib_tvalid	<=	'1';
					uncalib_tdata(BIT_FID + BIT_COARSE + BIT_UNCALIBRATED -1 downto BIT_COARSE + BIT_UNCALIBRATED)	<=	FID_OVERFLOW;
					if 	INTERNAL_OVERFLOW_CNT = TRUE then
						uncalib_tdata(BIT_COARSE + BIT_UNCALIBRATED -1 downto 0)									<=	std_logic_vector(CoarseOverflow_cnt);
						CoarseOverflow_cnt	<=	CoarseOverflow_cnt + 1;

					end if;

					-- Prepare the Measure
					queue				<=	'1';
					if dout_polarity = "1" then
						uncalib_tdata_tmp	<= FID_MEAS_RISE&dout_coarse&dout_uncalibrated;
					elsif dout_polarity = "0" then
						uncalib_tdata_tmp	<= FID_MEAS_FALL&dout_coarse&dout_uncalibrated;
					end if;

				end if;

			end if;

			if queue = '1' then
				uncalib_tvalid	<=	'1';
				uncalib_tdata	<=	uncalib_tdata_tmp;

				queue <= '0';
			end if;


		end if;

	end process;
	-----------------------------------------


	----------------------------------------------------------------------------





end Behavioral;
